---
phase: 05-hotkey-modifiers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Coxixo/Models/HotkeyCombo.cs
  - Coxixo/Models/AppSettings.cs
  - Coxixo/Services/KeyboardHookService.cs
  - Coxixo/Services/HotkeyValidator.cs
autonomous: true

must_haves:
  truths:
    - "Hotkey combination with modifiers can be persisted and loaded from settings"
    - "Keyboard hook fires only when exact modifier+key combination matches"
    - "Bare keys with no modifiers still work (backward compatible with v1.0 F8 default)"
    - "Reserved system combinations are identified and categorized"
    - "Risky but allowed combinations are identified for soft warning"
  artifacts:
    - path: "Coxixo/Models/HotkeyCombo.cs"
      provides: "Data model for hotkey combination with modifier flags"
      exports: ["HotkeyCombo"]
    - path: "Coxixo/Models/AppSettings.cs"
      provides: "Updated settings with HotkeyCombo replacing Keys HotkeyKey"
      contains: "HotkeyCombo"
    - path: "Coxixo/Services/KeyboardHookService.cs"
      provides: "Modifier-aware hook matching using GetKeyState"
      contains: "GetKeyState"
    - path: "Coxixo/Services/HotkeyValidator.cs"
      provides: "Reserved key blocking and soft warning detection"
      exports: ["HotkeyValidator"]
  key_links:
    - from: "KeyboardHookService.HookCallback"
      to: "HotkeyCombo"
      via: "Modifier state comparison using GetKeyState"
      pattern: "GetKeyState.*0x8000"
    - from: "AppSettings.Hotkey"
      to: "HotkeyCombo"
      via: "Property type change"
      pattern: "HotkeyCombo.*Hotkey"
    - from: "HotkeyValidator"
      to: "HotkeyCombo"
      via: "Validates combo against reserved/warned lists"
      pattern: "IsReserved|IsWarned"
---

<objective>
Create the data model, modifier-aware keyboard hook, and hotkey validation logic.

Purpose: Establish the foundation for modifier-key support. The HotkeyCombo model replaces the single-key approach, the keyboard hook gains modifier state detection via GetKeyState, and the validator enforces reserved/warned key policies. This plan touches only the service/model layer -- no UI changes.

Output: HotkeyCombo.cs, updated AppSettings.cs, modifier-aware KeyboardHookService.cs, HotkeyValidator.cs.
</objective>

<execution_context>
@C:/Users/Myke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Myke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-hotkey-modifiers/05-RESEARCH.md
@Coxixo/Models/AppSettings.cs
@Coxixo/Services/KeyboardHookService.cs
@Coxixo/Services/ConfigurationService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HotkeyCombo model and update AppSettings</name>
  <files>
    Coxixo/Models/HotkeyCombo.cs
    Coxixo/Models/AppSettings.cs
  </files>
  <action>
Create `Coxixo/Models/HotkeyCombo.cs` — a data model representing a hotkey combination:

```csharp
namespace Coxixo.Models;

public class HotkeyCombo
{
    public Keys Key { get; set; } = Keys.F8;
    public bool Ctrl { get; set; }
    public bool Alt { get; set; }
    public bool Shift { get; set; }

    // Display as badge-friendly segments: ["Ctrl", "Shift", "F8"]
    public string[] ToSegments() { ... }

    // Display as plain text for tooltips: "Ctrl+Shift+F8"
    public string ToDisplayString() { ... }

    // Check if any modifiers are set
    public bool HasModifiers => Ctrl || Alt || Shift;

    // Default factory
    public static HotkeyCombo Default() => new() { Key = Keys.F8 };
}
```

Key behaviors:
- `ToSegments()` returns an array of strings: modifier names first (in order Ctrl, Alt, Shift), then the key name. E.g., `["Ctrl", "Shift", "F8"]`. This feeds the badge UI in Plan 02.
- `ToDisplayString()` joins segments with "+". E.g., `"Ctrl+Shift+F8"`. This feeds the tray tooltip.
- For the key name, use `Key.ToString()` which gives "F8", "X", "Home" etc.
- Override `Equals` and `GetHashCode` for value equality (compare Key, Ctrl, Alt, Shift).

Update `Coxixo/Models/AppSettings.cs`:
- Replace `public Keys HotkeyKey { get; set; } = Keys.F8;` with `public HotkeyCombo Hotkey { get; set; } = HotkeyCombo.Default();`
- Remove the `using System.Windows.Forms;` if it was only there for Keys (but Keys is in System.Windows.Forms, so keep it).

**Backward compatibility:** The JSON serializer (System.Text.Json with camelCase) will now serialize `hotkey` as an object `{"key":"F8","ctrl":false,"alt":false,"shift":false}` instead of the old `"hotkeyKey":"F8"`. The old format will deserialize to default (new AppSettings returns F8 default) because the property name changed. This is acceptable — v1.0 users get their F8 default preserved. The old `hotkeyKey` field in existing JSON will be ignored by the deserializer (no matching property), which is safe.

Do NOT add a `[JsonConverter]` or custom migration — the default behavior is correct.
  </action>
  <verify>
- `dotnet build Coxixo/Coxixo.csproj` succeeds (expect compilation errors in SettingsForm.cs and TrayApplicationContext.cs referencing the old `HotkeyKey` — that's fine, those will be fixed in Plan 02)
- Actually: to keep builds green, also do a quick find-replace of `_settings.HotkeyKey` → `_settings.Hotkey.Key` and `_selectedKey` references in SettingsForm.cs/TrayApplicationContext.cs as a minimal compatibility shim. The full rework happens in Plan 02 but builds must pass now.
  </verify>
  <done>
- HotkeyCombo.cs exists with Key, Ctrl, Alt, Shift properties plus ToSegments(), ToDisplayString(), value equality
- AppSettings.cs uses HotkeyCombo instead of Keys for hotkey storage
- `dotnet build` succeeds with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add modifier detection to KeyboardHookService</name>
  <files>Coxixo/Services/KeyboardHookService.cs</files>
  <action>
Extend KeyboardHookService to match modifier+key combinations using GetKeyState.

Changes:

1. Add P/Invoke for `GetKeyState`:
   ```csharp
   [DllImport("user32.dll")]
   private static extern short GetKeyState(int nVirtKey);

   private const int VK_CONTROL = 0x11;
   private const int VK_SHIFT = 0x10;
   private const int VK_MENU = 0x12; // Alt
   ```

2. Replace `_targetKey` field with `_targetCombo`:
   ```csharp
   private HotkeyCombo _targetCombo = HotkeyCombo.Default();
   ```

3. Replace `TargetKey` property with `TargetCombo`:
   ```csharp
   public HotkeyCombo TargetCombo
   {
       get => _targetCombo;
       set => _targetCombo = value ?? HotkeyCombo.Default();
   }
   ```

4. Add helper to check if a modifier key is currently pressed:
   ```csharp
   private static bool IsKeyDown(int vk) => (GetKeyState(vk) & 0x8000) != 0;
   ```

5. Update `HookCallback` matching logic:
   ```csharp
   if (key == _targetCombo.Key)
   {
       // Check modifier state matches exactly
       bool ctrlDown = IsKeyDown(VK_CONTROL);
       bool altDown = IsKeyDown(VK_MENU);
       bool shiftDown = IsKeyDown(VK_SHIFT);

       bool modifiersMatch = ctrlDown == _targetCombo.Ctrl
                          && altDown == _targetCombo.Alt
                          && shiftDown == _targetCombo.Shift;

       if (modifiersMatch)
       {
           // existing press/release logic unchanged
       }
   }
   ```

   **IMPORTANT:** Use `GetKeyState`, NOT `GetAsyncKeyState`. GetKeyState is synchronized with the hook message queue and gives correct results in the hook callback. GetAsyncKeyState queries hardware state directly and can be desynchronized, causing intermittent missed/phantom modifiers.

6. Also handle the edge case: if the user releases a modifier key before releasing the main key, treat it as a release event. Add to HookCallback:
   ```csharp
   // If a modifier key is released while we're in keyDown state,
   // and the target combo requires that modifier, fire release.
   if (_isKeyDown && (msg == WM_KEYUP || msg == WM_SYSKEYUP))
   {
       bool isModifierRelease = key == Keys.ControlKey || key == Keys.LControlKey || key == Keys.RControlKey
                             || key == Keys.ShiftKey || key == Keys.LShiftKey || key == Keys.RShiftKey
                             || key == Keys.Menu || key == Keys.LMenu || key == Keys.RMenu;

       if (isModifierRelease)
       {
           // Re-check if modifiers still match; if not, treat as release
           bool ctrlDown = IsKeyDown(VK_CONTROL);
           bool altDown = IsKeyDown(VK_MENU);
           bool shiftDown = IsKeyDown(VK_SHIFT);
           bool stillMatch = ctrlDown == _targetCombo.Ctrl
                          && altDown == _targetCombo.Alt
                          && shiftDown == _targetCombo.Shift;
           if (!stillMatch)
           {
               _isKeyDown = false;
               HotkeyReleased?.Invoke(this, EventArgs.Empty);
           }
       }
   }
   ```
   This ensures push-to-talk recording stops if the user releases Ctrl before releasing F8 in a Ctrl+F8 combo. Critical for push-to-talk ergonomics.

7. Update compat shims in TrayApplicationContext.cs:
   - Replace `_hotkeyService.TargetKey = _settings.HotkeyKey;` with `_hotkeyService.TargetCombo = _settings.Hotkey;`
   - Replace tooltip references: `_settings.HotkeyKey` → `_settings.Hotkey.ToDisplayString()`
   - The tooltip format becomes: `$"Coxixo - Hold {_settings.Hotkey.ToDisplayString()} to record"`
  </action>
  <verify>
- `dotnet build Coxixo/Coxixo.csproj` succeeds with no errors
- Run app: F8 (no modifiers) still triggers recording as before (backward compat)
- Tray tooltip shows "Coxixo - Hold F8 to record"
  </verify>
  <done>
- KeyboardHookService uses GetKeyState for modifier detection
- TargetCombo property accepts HotkeyCombo
- Exact modifier matching: fires only when all required modifiers are held and no extra modifiers present
- Modifier release during hold triggers HotkeyReleased (push-to-talk safety)
- TrayApplicationContext passes HotkeyCombo to hook service
- Backward compatible: bare F8 default works identically to v1.0
  </done>
</task>

<task type="auto">
  <name>Task 3: Create HotkeyValidator for reserved keys and conflict warnings</name>
  <files>Coxixo/Services/HotkeyValidator.cs</files>
  <action>
Create `Coxixo/Services/HotkeyValidator.cs` — a static utility that validates hotkey combinations.

```csharp
namespace Coxixo.Services;

public static class HotkeyValidator
{
    public enum ValidationResult { Valid, Reserved, Warned }

    public record ValidationOutcome(ValidationResult Result, string? Message);
}
```

**Three categories:**

1. **Reserved (hard-blocked)** — cannot be set as hotkey. Return `Reserved` with explanation.

   Reserved combos:
   - F12 alone: "F12 is reserved for debugger attach in Windows"
   - Ctrl+Alt+Delete: "Ctrl+Alt+Delete is a Windows security interrupt"
   - Any combo with Win key (LWin/RWin as modifier): "Win key combinations conflict with Windows shell shortcuts"
   - Alt+F4: "Alt+F4 closes the active window"
   - Ctrl+Alt+F4: "Reserved Windows MDI shortcut"
   - PrintScreen (alone or with modifiers): "PrintScreen is reserved for screenshots"
   - Escape: "Escape cannot be used as a hotkey"

   Also block modifier-only presses — the validator should reject if `combo.Key` is a modifier key itself (ControlKey, ShiftKey, Menu, LWin, RWin) or Keys.None.

2. **Warned (soft-blocked)** — allowed with warning message. Return `Warned` with specific message.

   Warned combos:
   - Ctrl+C, Ctrl+V, Ctrl+X, Ctrl+A: "This may interfere with clipboard shortcuts"
   - Ctrl+Z, Ctrl+Y: "This may interfere with undo/redo"
   - Ctrl+S: "This may interfere with saving in other apps"
   - Ctrl+W: "This may interfere with closing tabs in browsers"
   - Alt+Tab: "This may interfere with window switching"

3. **Valid** — no issues. Return `Valid` with null message.

Public API:
```csharp
public static ValidationOutcome Validate(HotkeyCombo combo)
```

Implementation approach:
- Use a `HashSet<(Keys key, bool ctrl, bool alt, bool shift)>` for reserved lookups (fast O(1)).
- Use a `Dictionary<(Keys, bool, bool, bool), string>` for warned lookups with their specific messages.
- Check reserved first, then warned, then return valid.

Do NOT over-engineer: no runtime conflict detection with RegisterHotKey in this task. That goes in Plan 02 at save time.
  </action>
  <verify>
- `dotnet build Coxixo/Coxixo.csproj` succeeds
- Spot-check: `HotkeyValidator.Validate(new HotkeyCombo { Key = Keys.F12 })` returns Reserved
- Spot-check: `HotkeyValidator.Validate(new HotkeyCombo { Key = Keys.C, Ctrl = true })` returns Warned
- Spot-check: `HotkeyValidator.Validate(new HotkeyCombo { Key = Keys.F8 })` returns Valid
  </verify>
  <done>
- HotkeyValidator.cs exists with Validate() method
- Reserved combos blocked: F12, Ctrl+Alt+Del, Win+anything, Alt+F4, PrintScreen, Escape, modifier-only
- Warned combos flagged: Ctrl+C/V/X/A/Z/Y/S/W, Alt+Tab
- Valid combos pass through with no message
- Static utility, no external dependencies
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `dotnet build Coxixo/Coxixo.csproj` succeeds with zero errors
2. Run app: F8 push-to-talk works identically to v1.0 (backward compat)
3. Tray tooltip displays "Coxixo - Hold F8 to record"
4. HotkeyCombo model serializes/deserializes correctly via System.Text.Json
5. HotkeyValidator correctly categorizes reserved, warned, and valid combos
</verification>

<success_criteria>
- HKEY-01 foundation: HotkeyCombo model supports modifier flags
- HKEY-02 foundation: KeyboardHookService matches multi-modifier combinations
- HKEY-05 foundation: HotkeyValidator enforces reserved key policy
- Backward compatible: existing v1.0 F8 default preserved
- Build succeeds, app runs without regression
</success_criteria>

<output>
After completion, create `.planning/phases/05-hotkey-modifiers/05-01-SUMMARY.md`
</output>
