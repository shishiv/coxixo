---
phase: 05-hotkey-modifiers
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - Coxixo/Controls/HotkeyPickerControl.cs
  - Coxixo/Forms/SettingsForm.cs
  - Coxixo/Forms/SettingsForm.Designer.cs
  - Coxixo/TrayApplicationContext.cs
autonomous: true

must_haves:
  truths:
    - "User can click the hotkey picker, hold modifiers, press a key, and see the combination captured"
    - "Each key in the combination is displayed as an individual styled badge (not plain text)"
    - "Modifier badges show in pending state while held, before the main key is pressed"
    - "Pressing Escape during capture cancels and restores previous hotkey"
    - "Pressing Delete/Backspace during capture clears hotkey to default F8"
    - "Reserved combinations show red error message below picker and are rejected"
    - "Warned combinations show yellow caution message below picker with option to proceed"
    - "Conflicting hotkeys (registered by other apps) are detected on save and blocked"
    - "Saved hotkey combination persists and takes effect immediately"
    - "Tray tooltip shows full combination (e.g., Hold Ctrl+Shift+F8 to record)"
  artifacts:
    - path: "Coxixo/Controls/HotkeyPickerControl.cs"
      provides: "Custom UserControl with badge-based hotkey capture"
      exports: ["HotkeyPickerControl"]
    - path: "Coxixo/Forms/SettingsForm.cs"
      provides: "Updated settings form using HotkeyPickerControl with validation messages"
      contains: "HotkeyPickerControl"
    - path: "Coxixo/Forms/SettingsForm.Designer.cs"
      provides: "Designer partial updated to use HotkeyPickerControl instead of TextBox"
    - path: "Coxixo/TrayApplicationContext.cs"
      provides: "Settings reload passes full HotkeyCombo to hook service"
      contains: "TargetCombo"
  key_links:
    - from: "HotkeyPickerControl"
      to: "HotkeyCombo"
      via: "SelectedCombo property"
      pattern: "SelectedCombo"
    - from: "HotkeyPickerControl"
      to: "HotkeyValidator"
      via: "Validates on capture"
      pattern: "HotkeyValidator\\.Validate"
    - from: "SettingsForm.BtnSave_Click"
      to: "RegisterHotKey probe"
      via: "Conflict detection before save"
      pattern: "RegisterHotKey"
    - from: "SettingsForm.BtnSave_Click"
      to: "AppSettings.Hotkey"
      via: "Persist validated combo"
      pattern: "_settings\\.Hotkey"
    - from: "TrayApplicationContext.OnSettingsClick"
      to: "KeyboardHookService.TargetCombo"
      via: "Apply saved combo"
      pattern: "TargetCombo\\s*=.*Hotkey"
---

<objective>
Build the badge-based hotkey picker control and integrate it into the settings form with validation and conflict detection.

Purpose: This is the user-facing plan — the picker UI with styled key badges (locked decision), real-time validation feedback, RegisterHotKey conflict probing on save, and tray integration. Completes all HKEY requirements.

Output: HotkeyPickerControl.cs, updated SettingsForm with picker + validation messages, conflict detection on save, tray tooltip update.
</objective>

<execution_context>
@C:/Users/Myke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Myke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-hotkey-modifiers/05-RESEARCH.md
@.planning/phases/05-hotkey-modifiers/05-01-SUMMARY.md
@Coxixo/Models/HotkeyCombo.cs
@Coxixo/Models/AppSettings.cs
@Coxixo/Services/HotkeyValidator.cs
@Coxixo/Services/KeyboardHookService.cs
@Coxixo/Forms/SettingsForm.cs
@Coxixo/Forms/SettingsForm.Designer.cs
@Coxixo/TrayApplicationContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HotkeyPickerControl with badge rendering and capture</name>
  <files>Coxixo/Controls/HotkeyPickerControl.cs</files>
  <action>
Create `Coxixo/Controls/` directory and `HotkeyPickerControl.cs` — a custom UserControl that replaces the TextBox hotkey picker.

**LOCKED DECISION:** Combo displayed as individual styled badges per key, not plain text.

**Control architecture:**
```
HotkeyPickerControl : UserControl
  - Owner-drawn (override OnPaint for badges)
  - Capture mode toggled on click
  - Exposes SelectedCombo property (HotkeyCombo)
  - Fires ComboChanged event
  - Shows validation message via ValidationMessage property
```

**Visual design (dark theme):**
- Control background: `#252526` (DarkTheme.Surface)
- Control border: `#3C3C3C` (DarkTheme.Border), 1px
- When focused/capturing: border changes to `#0078D4` (DarkTheme.Primary)
- Badge background: `#005A9E` (WCAG AA compliant, darker shade of primary)
- Badge text: `#FFFFFF`
- Badge corner radius: 3px
- Badge padding: 6px horizontal, 2px vertical
- Badge spacing: 4px gap between badges
- Badge font: Segoe UI 8pt bold
- Pending badge state (modifiers held, no main key yet): badge background `#3C3C3C` (border color), text `#808080` (muted)
- Empty state placeholder: "Click to set hotkey..." in `#808080` (TextMuted)

**Capture flow:**
1. User clicks control → enters capture mode:
   - Border turns primary blue
   - Clear any existing badges
   - Show placeholder "Press a key combination..."
2. User holds modifier(s) → modifier badges appear in pending (dim) state, updated live
3. User presses a non-modifier key → combination captured:
   - Call `HotkeyValidator.Validate(combo)` immediately
   - If Reserved: set `ValidationMessage` (red), do NOT accept the combo, stay in capture mode
   - If Warned: set `ValidationMessage` (yellow), accept the combo, exit capture mode
   - If Valid: clear `ValidationMessage`, accept the combo, exit capture mode
   - Badges update to confirmed (bright) state
   - Fire `ComboChanged` event
4. Escape pressed → cancel capture, restore previous SelectedCombo, clear validation message
5. Delete or Backspace pressed → set combo to default F8, exit capture mode, fire ComboChanged

**Key capture implementation:**
Override `ProcessCmdKey(ref Message msg, Keys keyData)` — this intercepts system keys (Tab, Enter, arrows) before KeyDown.

```csharp
protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
{
    if (!_isCapturing) return base.ProcessCmdKey(ref msg, keyData);

    var modifiers = keyData & Keys.Modifiers;
    var key = keyData & Keys.KeyCode;

    // Escape cancels
    if (key == Keys.Escape)
    {
        CancelCapture();
        return true;
    }

    // Delete/Backspace resets to default
    if (key == Keys.Delete || key == Keys.Back)
    {
        ResetToDefault();
        return true;
    }

    // Ignore modifier-only presses (they update preview)
    if (key == Keys.ControlKey || key == Keys.ShiftKey || key == Keys.Menu
        || key == Keys.LWin || key == Keys.RWin)
        return true;

    // Build combo from captured input
    var combo = new HotkeyCombo
    {
        Key = key,
        Ctrl = modifiers.HasFlag(Keys.Control),
        Alt = modifiers.HasFlag(Keys.Alt),
        Shift = modifiers.HasFlag(Keys.Shift)
    };

    // Validate
    var validation = HotkeyValidator.Validate(combo);
    if (validation.Result == HotkeyValidator.ValidationResult.Reserved)
    {
        _validationMessage = validation.Message;
        _validationSeverity = "error";
        Invalidate(); // Redraw to show error
        // Do NOT accept — stay in capture mode
        ValidationChanged?.Invoke(this, EventArgs.Empty);
        return true;
    }

    // Warned or Valid — accept
    SelectedCombo = combo;
    _validationMessage = validation.Message;
    _validationSeverity = validation.Result == HotkeyValidator.ValidationResult.Warned ? "warn" : null;
    _isCapturing = false;
    Invalidate();
    ComboChanged?.Invoke(this, EventArgs.Empty);
    ValidationChanged?.Invoke(this, EventArgs.Empty);
    return true;
}
```

**Live modifier preview:**
Override `OnKeyDown` and `OnKeyUp` to track which modifiers are currently held during capture. On each change, update the pending badge display and call `Invalidate()`.

**OnPaint badge rendering:**
```csharp
protected override void OnPaint(PaintEventArgs e)
{
    var g = e.Graphics;
    g.SmoothingMode = SmoothingMode.AntiAlias;

    // Draw background
    // Draw border (normal or focused color)

    if (SelectedCombo == null && !_isCapturing)
    {
        // Draw placeholder text
    }
    else
    {
        // Get segments to render
        var segments = _isCapturing ? GetPendingSegments() : SelectedCombo.ToSegments();

        // Draw each badge
        float x = 8;  // left padding
        float y = (Height - badgeHeight) / 2;  // vertically centered

        foreach (var segment in segments)
        {
            var size = g.MeasureString(segment, _badgeFont);
            var badgeRect = new RectangleF(x, y, size.Width + 12, size.Height + 4);

            // Choose colors based on state (pending vs confirmed)
            var bgColor = isPending ? _borderColor : _badgeBgColor;
            var textColor = isPending ? _mutedColor : Color.White;

            // Draw rounded rectangle badge
            using var path = CreateRoundedRect(badgeRect, 3);
            using var brush = new SolidBrush(bgColor);
            g.FillPath(brush, path);

            // Draw text centered in badge
            g.DrawString(segment, _badgeFont, textBrush, badgeRect, _centerFormat);

            x += badgeRect.Width + 4;  // gap between badges
        }
    }
}
```

Use `SuspendLayout()`/`ResumeLayout()` is not needed here since we use owner-draw (OnPaint) rather than child controls. This avoids the FlowLayoutPanel flicker issue noted in research.

**Public API:**
```csharp
public HotkeyCombo SelectedCombo { get; set; }
public string? ValidationMessage => _validationMessage;
public string? ValidationSeverity => _validationSeverity; // "error", "warn", or null
public event EventHandler? ComboChanged;
public event EventHandler? ValidationChanged;
```

Set `this.SetStyle(ControlStyles.Selectable | ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer, true)` in constructor for flicker-free rendering and keyboard focus support.

Set `this.Cursor = Cursors.Hand` for click affordance.
Set reasonable `MinimumSize = new Size(100, 28)`.
  </action>
  <verify>
- `dotnet build Coxixo/Coxixo.csproj` succeeds
- HotkeyPickerControl.cs exists in Coxixo/Controls/
- Control compiles with no warnings about missing types
  </verify>
  <done>
- HotkeyPickerControl exists as owner-drawn UserControl
- Badge rendering: individual rounded-rect badges for each key segment
- Capture mode: click to enter, modifiers show as pending badges, key press confirms
- Escape cancels, Delete/Backspace resets to F8 default
- Validation on capture: reserved combos rejected, warned combos accepted with message
- ComboChanged and ValidationChanged events exposed
- Dark theme colors: #005A9E badge bg, #3C3C3C pending, #FFFFFF text
- WCAG AA contrast on badge text
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate picker into SettingsForm with conflict detection on save</name>
  <files>
    Coxixo/Forms/SettingsForm.cs
    Coxixo/Forms/SettingsForm.Designer.cs
    Coxixo/TrayApplicationContext.cs
  </files>
  <action>
Replace the TextBox hotkey picker with HotkeyPickerControl in the settings form. Add a validation message label below the picker. Add RegisterHotKey conflict probe on save.

**SettingsForm.Designer.cs changes:**

1. Remove `txtHotkey` TextBox field and its initialization.

2. Add new fields:
   ```csharp
   private Controls.HotkeyPickerControl hotkeyPicker;
   private Label lblHotkeyMessage;
   ```

3. In InitializeComponent, replace txtHotkey setup with:
   ```csharp
   // hotkeyPicker
   hotkeyPicker = new Controls.HotkeyPickerControl();
   hotkeyPicker.Location = new Point(12, 105);
   hotkeyPicker.Size = new Size(280, 32);
   hotkeyPicker.Name = "hotkeyPicker";

   // lblHotkeyMessage (validation feedback below picker)
   lblHotkeyMessage = new Label();
   lblHotkeyMessage.Location = new Point(12, 140);
   lblHotkeyMessage.Size = new Size(280, 16);
   lblHotkeyMessage.Font = new Font("Segoe UI", 7.5F);
   lblHotkeyMessage.Name = "lblHotkeyMessage";
   lblHotkeyMessage.Text = "";
   lblHotkeyMessage.Visible = false;
   ```

4. Replace `txtHotkey` in Controls.Add with `hotkeyPicker`. Add `lblHotkeyMessage` after it.

5. Shift all controls below the hotkey field down by ~10px to make room for the validation label (adjust Y positions of lblEndpoint, txtEndpoint, lblApiKey, txtApiKey, lblDeployment, txtDeployment, btnTestConnection, btnCancel, btnSave). Increase form ClientSize height to accommodate (from 391 to about 405).

**SettingsForm.cs changes:**

1. Remove old hotkey capture logic:
   - Remove `_selectedKey` field
   - Remove `_isCapturingHotkey` field
   - Remove `TxtHotkey_Enter`, `TxtHotkey_Leave`, `TxtHotkey_KeyDown` methods
   - Remove `ProcessCmdKey` override (the picker control handles its own capture now)

2. Add using for Models and Controls:
   ```csharp
   using Coxixo.Controls;
   using Coxixo.Models;
   ```

3. Update `LoadSettings()`:
   ```csharp
   private void LoadSettings()
   {
       _settings = ConfigurationService.Load();
       hotkeyPicker.SelectedCombo = _settings.Hotkey;
       txtEndpoint.Text = _settings.AzureEndpoint;
       txtApiKey.Text = CredentialService.LoadApiKey() ?? "";
       txtDeployment.Text = _settings.WhisperDeployment;
   }
   ```

4. Wire up validation message display in SetupForm() or after InitializeComponent():
   ```csharp
   hotkeyPicker.ValidationChanged += OnHotkeyValidationChanged;
   ```

   ```csharp
   private void OnHotkeyValidationChanged(object? sender, EventArgs e)
   {
       if (hotkeyPicker.ValidationMessage != null)
       {
           lblHotkeyMessage.Text = hotkeyPicker.ValidationMessage;
           lblHotkeyMessage.ForeColor = hotkeyPicker.ValidationSeverity == "error"
               ? DarkTheme.Error
               : Color.FromArgb(0xFF, 0xB9, 0x00); // Warning yellow
           lblHotkeyMessage.Visible = true;
       }
       else
       {
           lblHotkeyMessage.Visible = false;
       }
   }
   ```

5. Update `BtnSave_Click` to validate with RegisterHotKey probe before saving:
   ```csharp
   private void BtnSave_Click(object? sender, EventArgs e)
   {
       var combo = hotkeyPicker.SelectedCombo;

       // Re-validate (in case state changed)
       var validation = HotkeyValidator.Validate(combo);
       if (validation.Result == HotkeyValidator.ValidationResult.Reserved)
       {
           lblHotkeyMessage.Text = validation.Message ?? "This combination is reserved.";
           lblHotkeyMessage.ForeColor = DarkTheme.Error;
           lblHotkeyMessage.Visible = true;
           return; // Block save
       }

       // Probe for conflicts using RegisterHotKey
       if (!ProbeHotkeyConflict(combo))
       {
           lblHotkeyMessage.Text = "This hotkey is already in use by another application. Choose a different combination.";
           lblHotkeyMessage.ForeColor = DarkTheme.Error;
           lblHotkeyMessage.Visible = true;
           return; // Block save
       }

       // Update settings
       _settings.Hotkey = combo;
       _settings.AzureEndpoint = txtEndpoint.Text.Trim();
       _settings.WhisperDeployment = txtDeployment.Text.Trim();

       // Save settings
       ConfigurationService.Save(_settings);

       // Save API key securely
       var apiKey = txtApiKey.Text.Trim();
       if (!string.IsNullOrEmpty(apiKey))
       {
           CredentialService.SaveApiKey(apiKey);
       }

       this.DialogResult = DialogResult.OK;
       this.Close();
   }
   ```

6. Add the RegisterHotKey probe method:
   ```csharp
   [DllImport("user32.dll", SetLastError = true)]
   private static extern bool RegisterHotKey(IntPtr hWnd, int id, uint fsModifiers, uint vk);

   [DllImport("user32.dll", SetLastError = true)]
   private static extern bool UnregisterHotKey(IntPtr hWnd, int id);

   private const uint MOD_ALT = 0x0001;
   private const uint MOD_CONTROL = 0x0002;
   private const uint MOD_SHIFT = 0x0004;

   /// <summary>
   /// Probes whether the hotkey combination is available by temporarily registering it.
   /// Returns true if available, false if conflicting with another app.
   /// </summary>
   private bool ProbeHotkeyConflict(HotkeyCombo combo)
   {
       uint modifiers = 0;
       if (combo.Ctrl) modifiers |= MOD_CONTROL;
       if (combo.Alt) modifiers |= MOD_ALT;
       if (combo.Shift) modifiers |= MOD_SHIFT;

       // If no modifiers and it's an F-key or special key, RegisterHotKey still works
       // Use a unique ID (e.g., 0x7FFF) for the probe
       bool registered = RegisterHotKey(this.Handle, 0x7FFF, modifiers, (uint)combo.Key);

       if (registered)
       {
           // Available — immediately unregister
           UnregisterHotKey(this.Handle, 0x7FFF);
           return true;
       }

       return false; // Conflict detected
   }
   ```

   **Note on bare keys:** `RegisterHotKey` with `modifiers=0` and a regular letter key may fail because Windows requires at least one modifier for RegisterHotKey. For bare keys (no modifiers), SKIP the probe and return true — our low-level hook approach doesn't conflict with RegisterHotKey-based apps for unmodified keys. Only probe when at least one modifier is set.

   Update the probe:
   ```csharp
   private bool ProbeHotkeyConflict(HotkeyCombo combo)
   {
       // RegisterHotKey requires at least one modifier for non-F-key/non-special keys
       // For bare keys (no modifiers), skip probe — low-level hooks don't conflict with RegisterHotKey
       if (!combo.HasModifiers) return true;

       uint modifiers = 0;
       if (combo.Ctrl) modifiers |= MOD_CONTROL;
       if (combo.Alt) modifiers |= MOD_ALT;
       if (combo.Shift) modifiers |= MOD_SHIFT;

       bool registered = RegisterHotKey(this.Handle, 0x7FFF, modifiers, (uint)combo.Key);
       if (registered)
       {
           UnregisterHotKey(this.Handle, 0x7FFF);
           return true;
       }
       return false;
   }
   ```

7. Update `ApplyDarkTheme` to handle the new control types:
   Add a case for `HotkeyPickerControl` — though it handles its own painting, the recursive walker should not override its colors. If needed, skip it or apply BackColor.

**TrayApplicationContext.cs changes:**

Ensure the OnSettingsClick handler properly reloads the full HotkeyCombo after settings save. This should already work from Plan 01 compat shim, but verify:
```csharp
if (settingsForm.DialogResult == DialogResult.OK)
{
    _settings = ConfigurationService.Load();
    _hotkeyService.TargetCombo = _settings.Hotkey;
    _trayIcon.Text = $"Coxixo - Hold {_settings.Hotkey.ToDisplayString()} to record";
    TryInitializeTranscriptionService();
}
```

Also update the constructor tooltip:
```csharp
Text = $"Coxixo - Hold {_settings.Hotkey.ToDisplayString()} to record"
```

And all other places that reference `_settings.HotkeyKey` or `_settings.Hotkey.Key` directly for display — replace with `_settings.Hotkey.ToDisplayString()`.
  </action>
  <verify>
- `dotnet build Coxixo/Coxixo.csproj` succeeds
- Run app, open Settings:
  1. Hotkey picker shows current combo as badges (default: single "F8" badge)
  2. Click picker, hold Ctrl+Shift, press F8: three badges appear ("Ctrl", "Shift", "F8")
  3. Try F12: red error message appears, combo not accepted
  4. Try Ctrl+C: yellow warning message appears, combo accepted
  5. Press Escape during capture: reverts to previous combo
  6. Click Save: combo saved, tray tooltip updates
  7. Re-open Settings: saved combo shown in badges
  </verify>
  <done>
- HotkeyPickerControl integrated into SettingsForm replacing TextBox
- Badge display: each key rendered as styled badge with dark theme colors
- Validation messages: red for reserved (blocks), yellow for warned (allows)
- RegisterHotKey probe on save detects conflicts with other applications
- Conflict blocks save with clear error message
- Saved combo propagated to KeyboardHookService and tray tooltip
- Full round-trip: capture → validate → save → reload → display
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify all HKEY requirements:

1. **HKEY-01** (single modifier): Open Settings, click picker, hold Ctrl, press F8 → "Ctrl" + "F8" badges shown → Save → hold Ctrl+F8 starts recording
2. **HKEY-02** (multi modifier): Open Settings, hold Ctrl+Alt, press X → three badges → Save → Ctrl+Alt+X triggers recording
3. **HKEY-03** (display): Badges render as individual styled elements, not "Ctrl+Alt+X" plain text
4. **HKEY-04** (conflict): Set a hotkey already registered by another app → "already in use" error on Save
5. **HKEY-05** (reserved): Try to set F12 → red "reserved for debugger" message, blocked. Try Win+X → blocked.
6. **Backward compat**: Default F8 (no modifiers) still works after upgrade
7. **Tray tooltip**: Shows "Hold Ctrl+Shift+F8 to record" format
8. `dotnet build Coxixo/Coxixo.csproj` succeeds
</verification>

<success_criteria>
- HKEY-01 complete: Single-modifier combos (Ctrl+F8, Alt+X, Shift+Home) work
- HKEY-02 complete: Multi-modifier combos (Ctrl+Alt+X, Ctrl+Shift+Y) work
- HKEY-03 complete: Picker shows individual styled badges per key
- HKEY-04 complete: Conflict detection on save with clear error message
- HKEY-05 complete: Reserved system combos blocked with explanation
- Backward compatible with v1.0 bare-key hotkeys
- Dark theme consistent with existing settings form
</success_criteria>

<output>
After completion, create `.planning/phases/05-hotkey-modifiers/05-02-SUMMARY.md`
</output>
