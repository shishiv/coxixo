---
phase: 04-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Coxixo/Forms/SettingsForm.cs
  - Coxixo/Forms/SettingsForm.Designer.cs
  - Coxixo/TrayApplicationContext.cs
  - Coxixo/Services/KeyboardHookService.cs
autonomous: true

must_haves:
  truths:
    - "User can open Settings window from tray menu"
    - "User can see and change the push-to-talk hotkey"
    - "User can enter Azure API credentials"
    - "User can see API connection status with latency"
    - "Settings window uses dark theme"
    - "Changed hotkey takes effect immediately after save"
  artifacts:
    - path: "Coxixo/Forms/SettingsForm.cs"
      provides: "Dark-themed settings window with all controls"
      exports: ["SettingsForm"]
    - path: "Coxixo/Forms/SettingsForm.Designer.cs"
      provides: "Designer partial for SettingsForm"
    - path: "Coxixo/TrayApplicationContext.cs"
      provides: "OnSettingsClick opens SettingsForm, applies saved settings"
      contains: "new SettingsForm"
  key_links:
    - from: "TrayApplicationContext.OnSettingsClick"
      to: "SettingsForm"
      via: "form.ShowDialog"
      pattern: "new SettingsForm.*ShowDialog"
    - from: "SettingsForm.Save"
      to: "ConfigurationService.Save"
      via: "persist settings"
      pattern: "ConfigurationService\\.Save"
    - from: "TrayApplicationContext"
      to: "KeyboardHookService.TargetKey"
      via: "apply new hotkey"
      pattern: "_hotkeyService\\.TargetKey\\s*="
---

<objective>
Build the Settings UI window with dark theme, hotkey customization, and API status.

Purpose: Provide user-facing configuration for the push-to-talk hotkey and Azure API credentials. The settings window follows the brand guide mockup: dark background (#1E1E1E), status indicator with latency, credential fields, and Save button.

Output: SettingsForm.cs with dark theme, hotkey picker, API fields, connection status, integrated into TrayApplicationContext.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-polish/04-RESEARCH.md
@Coxixo/TrayApplicationContext.cs
@Coxixo/Services/ConfigurationService.cs
@Coxixo/Services/CredentialService.cs
@Coxixo/Models/AppSettings.cs
@coxixo-brand-guides.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SettingsForm with dark theme and controls</name>
  <files>
    Coxixo/Forms/SettingsForm.cs
    Coxixo/Forms/SettingsForm.Designer.cs
  </files>
  <action>
Create a new SettingsForm matching the brand guide mockup (see coxixo-brand-guides.html "ui-mockup" tab).

Create Coxixo/Forms/ directory if it doesn't exist.

**SettingsForm.cs:**
```csharp
using System.Diagnostics;
using System.Net.Http;
using Coxixo.Models;
using Coxixo.Services;

namespace Coxixo.Forms;

public partial class SettingsForm : Form
{
    private static class DarkTheme
    {
        public static readonly Color Background = Color.FromArgb(0x1E, 0x1E, 0x1E);
        public static readonly Color Surface = Color.FromArgb(0x25, 0x25, 0x26);
        public static readonly Color Text = Color.White;
        public static readonly Color TextMuted = Color.FromArgb(0x80, 0x80, 0x80);
        public static readonly Color Border = Color.FromArgb(0x3C, 0x3C, 0x3C);
        public static readonly Color Primary = Color.FromArgb(0x00, 0x78, 0xD4);
        public static readonly Color Success = Color.FromArgb(0x00, 0xCC, 0x6A);
        public static readonly Color Error = Color.FromArgb(0xE8, 0x11, 0x23);
    }

    private Keys _selectedKey;
    private AppSettings _settings;
    private bool _isCapturingHotkey = false;

    public SettingsForm()
    {
        InitializeComponent();
        SetupForm();
        LoadSettings();
        _ = TestConnectionAsync(); // Fire and forget initial check
    }

    private void SetupForm()
    {
        // Form properties
        this.Text = "Coxixo Settings";
        this.Size = new Size(320, 420);
        this.FormBorderStyle = FormBorderStyle.FixedSingle;
        this.MaximizeBox = false;
        this.StartPosition = FormStartPosition.CenterScreen;
        this.Font = new Font("Segoe UI", 9F);

        ApplyDarkTheme(this);
    }

    private void ApplyDarkTheme(Control control)
    {
        control.BackColor = DarkTheme.Background;
        control.ForeColor = DarkTheme.Text;

        foreach (Control child in control.Controls)
        {
            if (child is TextBox tb)
            {
                tb.BackColor = DarkTheme.Surface;
                tb.ForeColor = DarkTheme.Text;
                tb.BorderStyle = BorderStyle.FixedSingle;
            }
            else if (child is Button btn)
            {
                btn.FlatStyle = FlatStyle.Flat;
                btn.FlatAppearance.BorderColor = DarkTheme.Border;
                if (btn.Name == "btnSave")
                {
                    btn.BackColor = DarkTheme.Primary;
                    btn.ForeColor = Color.White;
                }
                else
                {
                    btn.BackColor = DarkTheme.Surface;
                }
            }
            else if (child is Panel panel)
            {
                panel.BackColor = DarkTheme.Surface;
            }
            ApplyDarkTheme(child);
        }
    }

    private void LoadSettings()
    {
        _settings = ConfigurationService.Load();
        _selectedKey = _settings.HotkeyKey;

        txtHotkey.Text = _selectedKey.ToString();
        txtEndpoint.Text = _settings.AzureEndpoint;
        txtApiKey.Text = CredentialService.LoadApiKey() ?? "";
        txtDeployment.Text = _settings.WhisperDeployment;
    }

    private void TxtHotkey_Enter(object sender, EventArgs e)
    {
        _isCapturingHotkey = true;
        txtHotkey.Text = "Press a key...";
    }

    private void TxtHotkey_Leave(object sender, EventArgs e)
    {
        _isCapturingHotkey = false;
        txtHotkey.Text = _selectedKey.ToString();
    }

    private void TxtHotkey_KeyDown(object sender, KeyEventArgs e)
    {
        if (!_isCapturingHotkey) return;

        e.Handled = true;
        e.SuppressKeyPress = true;

        // Ignore modifier-only presses
        if (e.KeyCode == Keys.ControlKey || e.KeyCode == Keys.ShiftKey ||
            e.KeyCode == Keys.Menu || e.KeyCode == Keys.LWin || e.KeyCode == Keys.RWin)
            return;

        _selectedKey = e.KeyCode;
        txtHotkey.Text = _selectedKey.ToString();
        _isCapturingHotkey = false;
    }

    protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
    {
        // Allow Tab and other navigation keys to be captured as hotkey
        if (_isCapturingHotkey && txtHotkey.Focused)
        {
            var key = keyData & Keys.KeyCode;
            if (key != Keys.None && key != Keys.ControlKey && key != Keys.ShiftKey && key != Keys.Menu)
            {
                _selectedKey = key;
                txtHotkey.Text = _selectedKey.ToString();
                _isCapturingHotkey = false;
                return true;
            }
        }
        return base.ProcessCmdKey(ref msg, keyData);
    }

    private async Task TestConnectionAsync()
    {
        var endpoint = txtEndpoint.Text.Trim();
        var apiKey = txtApiKey.Text.Trim();

        if (string.IsNullOrEmpty(endpoint) || string.IsNullOrEmpty(apiKey))
        {
            UpdateConnectionStatus(false, 0, "Configure credentials");
            return;
        }

        UpdateConnectionStatus(null, 0, "Testing...");

        var stopwatch = Stopwatch.StartNew();
        try
        {
            using var client = new HttpClient();
            client.DefaultRequestHeaders.Add("api-key", apiKey);
            client.Timeout = TimeSpan.FromSeconds(5);

            var url = $"{endpoint.TrimEnd('/')}/openai/deployments?api-version=2024-02-01";
            var response = await client.GetAsync(url);
            stopwatch.Stop();

            var latency = (int)stopwatch.ElapsedMilliseconds;
            var connected = response.IsSuccessStatusCode ||
                           response.StatusCode == System.Net.HttpStatusCode.NotFound;

            UpdateConnectionStatus(connected, latency,
                connected ? "Connected" : $"Error: {response.StatusCode}");
        }
        catch (Exception ex)
        {
            UpdateConnectionStatus(false, 0, $"Error: {ex.Message}");
        }
    }

    private void UpdateConnectionStatus(bool? connected, int latencyMs, string message)
    {
        if (InvokeRequired)
        {
            Invoke(() => UpdateConnectionStatus(connected, latencyMs, message));
            return;
        }

        if (connected == true)
        {
            pnlStatus.BackColor = Color.FromArgb(20, 0, 80, 0);
            lblStatusIcon.ForeColor = DarkTheme.Success;
            lblStatusIcon.Text = "●";
            lblStatusText.Text = "Whisper API Connected";
            lblStatusText.ForeColor = DarkTheme.Success;
            lblLatency.Text = $"Latency: {latencyMs}ms";
            lblLatency.Visible = true;
        }
        else if (connected == false)
        {
            pnlStatus.BackColor = Color.FromArgb(20, 80, 0, 0);
            lblStatusIcon.ForeColor = DarkTheme.Error;
            lblStatusIcon.Text = "●";
            lblStatusText.Text = message;
            lblStatusText.ForeColor = DarkTheme.Error;
            lblLatency.Visible = false;
        }
        else // null = testing
        {
            pnlStatus.BackColor = DarkTheme.Surface;
            lblStatusIcon.ForeColor = DarkTheme.TextMuted;
            lblStatusIcon.Text = "○";
            lblStatusText.Text = message;
            lblStatusText.ForeColor = DarkTheme.TextMuted;
            lblLatency.Visible = false;
        }
    }

    private void BtnTestConnection_Click(object sender, EventArgs e)
    {
        _ = TestConnectionAsync();
    }

    private void BtnSave_Click(object sender, EventArgs e)
    {
        // Update settings
        _settings.HotkeyKey = _selectedKey;
        _settings.AzureEndpoint = txtEndpoint.Text.Trim();
        _settings.WhisperDeployment = txtDeployment.Text.Trim();

        // Save settings
        ConfigurationService.Save(_settings);

        // Save API key securely
        var apiKey = txtApiKey.Text.Trim();
        if (!string.IsNullOrEmpty(apiKey))
        {
            CredentialService.SaveApiKey(apiKey);
        }

        this.DialogResult = DialogResult.OK;
        this.Close();
    }

    private void BtnCancel_Click(object sender, EventArgs e)
    {
        this.DialogResult = DialogResult.Cancel;
        this.Close();
    }
}
```

**SettingsForm.Designer.cs:**
Create the designer partial with controls matching brand mockup layout:
- Status panel at top (green/red indicator, latency)
- Hotkey field (TextBox that captures key press)
- Azure Endpoint field
- API Key field (password masked)
- Deployment name field
- Test Connection button
- Save/Cancel buttons

Layout from top to bottom:
1. Status indicator panel (full width, 60px height)
2. "Hotkey" label + TextBox (read-only until clicked, then captures key)
3. "Azure Endpoint" label + TextBox
4. "API Key" label + TextBox (UseSystemPasswordChar = true)
5. "Deployment" label + TextBox
6. Test Connection link/button
7. Footer with Save and Cancel buttons

Key control names:
- pnlStatus, lblStatusIcon, lblStatusText, lblLatency
- txtHotkey, txtEndpoint, txtApiKey, txtDeployment
- btnTestConnection, btnSave, btnCancel
  </action>
  <verify>
- `dotnet build Coxixo/Coxixo.csproj` succeeds
- SettingsForm.cs and SettingsForm.Designer.cs exist in Coxixo/Forms/
  </verify>
  <done>
SettingsForm class exists with:
- Dark theme (#1E1E1E background, #252526 surface)
- Hotkey picker that captures key press
- API credential fields (endpoint, key masked, deployment)
- Connection status indicator with latency
- Save/Cancel buttons
- Segoe UI font
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire SettingsForm into TrayApplicationContext</name>
  <files>Coxixo/TrayApplicationContext.cs</files>
  <action>
Update TrayApplicationContext to open SettingsForm and apply changed settings.

Changes:

1. Add using statement:
   ```csharp
   using Coxixo.Forms;
   ```

2. Replace OnSettingsClick placeholder with working implementation:
   ```csharp
   private void OnSettingsClick(object? sender, EventArgs e)
   {
       using var settingsForm = new SettingsForm();

       // Temporarily unhook keyboard while settings is open
       // (so user can change hotkey without triggering recording)
       _hotkeyService.Stop();

       try
       {
           settingsForm.ShowDialog();

           if (settingsForm.DialogResult == DialogResult.OK)
           {
               // Reload settings
               var newSettings = ConfigurationService.Load();

               // Update hotkey
               _hotkeyService.TargetKey = newSettings.HotkeyKey;

               // Update tooltip
               _trayIcon.Text = $"Coxixo - Press {newSettings.HotkeyKey} to talk";

               // Reinitialize transcription service with new credentials
               TryInitializeTranscriptionService();
           }
       }
       finally
       {
           // Re-enable keyboard hook
           _hotkeyService.Start();
       }
   }
   ```

3. Make _settings field non-readonly so it can be refreshed after settings save:
   - Change `private readonly AppSettings _settings;`
   - To `private AppSettings _settings;`

4. Update all references to use refreshed settings after save.

Pattern reference: See 04-RESEARCH.md "Pitfall 6: Saving Settings While Hotkey Hook Active"
  </action>
  <verify>
- `dotnet build Coxixo/Coxixo.csproj` succeeds
- Run app, right-click tray -> Settings: SettingsForm opens
- Change hotkey, click Save: new hotkey works immediately
- Change API credentials, click Save: connection status updates
  </verify>
  <done>
Settings menu item opens SettingsForm:
- Keyboard hook paused while settings open (can capture new hotkey)
- DialogResult.OK triggers settings reload
- New hotkey immediately applies to KeyboardHookService
- New API credentials trigger TranscriptionService reinitialization
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Build succeeds: `dotnet build Coxixo/Coxixo.csproj`
2. Run the app: `dotnet run --project Coxixo/Coxixo.csproj`
3. Right-click tray icon -> Settings: dark-themed form opens
4. Verify dark theme colors match brand (#1E1E1E background)
5. Click hotkey field, press a key: field updates with new key name
6. Enter API credentials, click Test Connection: status updates
7. Click Save: settings persisted, hotkey change takes effect immediately
8. Re-open Settings: previously saved values are shown
</verification>

<success_criteria>
- CONF-01 satisfied: User can customize the push-to-talk hotkey
- UI-03 satisfied: Settings window follows dark theme
- UI-04 satisfied: Settings window shows API connection status with latency
- UI-05 satisfied: Color palette uses Azure Blue #0078D4
- UI-06 satisfied: Typography uses Segoe UI
- Hotkey change takes effect immediately after save (no restart required)
</success_criteria>

<output>
After completion, create `.planning/phases/04-polish/04-02-SUMMARY.md`
</output>
