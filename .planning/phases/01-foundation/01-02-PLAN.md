---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Coxixo/Services/KeyboardHookService.cs
  - Coxixo/TrayApplicationContext.cs
  - Coxixo/Resources/icon-recording.ico
autonomous: true

must_haves:
  truths:
    - "User can hold F8 key and tray icon changes to recording state"
    - "User can release F8 key and tray icon returns to idle state"
    - "Hotkey works when any application has focus (global)"
    - "Holding key does not trigger repeated events (no auto-repeat flood)"
  artifacts:
    - path: "Coxixo/Services/KeyboardHookService.cs"
      provides: "Low-level keyboard hook for push-to-talk"
      contains: "WH_KEYBOARD_LL"
      exports: ["HotkeyPressed", "HotkeyReleased"]
    - path: "Coxixo/Resources/icon-recording.ico"
      provides: "Recording state tray icon"
      min_size: 1000
  key_links:
    - from: "Coxixo/TrayApplicationContext.cs"
      to: "Coxixo/Services/KeyboardHookService.cs"
      via: "Event subscription for HotkeyPressed/HotkeyReleased"
      pattern: "_hotkeyService\\.Hotkey(Pressed|Released)\\s*\\+="
    - from: "Coxixo/Services/KeyboardHookService.cs"
      to: "user32.dll"
      via: "P/Invoke SetWindowsHookEx"
      pattern: "SetWindowsHookEx"
---

<objective>
Implement global hotkey detection with key press AND key release events for push-to-talk functionality.

Purpose: The push-to-talk UX requires detecting when user holds a key (start recording) and releases it (stop recording). The standard RegisterHotKey API only detects key press, so we must use a low-level keyboard hook (WH_KEYBOARD_LL) that captures both WM_KEYDOWN and WM_KEYUP messages.

Output: KeyboardHookService that fires HotkeyPressed when F8 is pressed and HotkeyReleased when F8 is released. Tray icon changes state to indicate recording.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement KeyboardHookService with low-level hook</name>
  <files>
    Coxixo/Services/KeyboardHookService.cs
  </files>
  <action>
Create Services folder and KeyboardHookService.cs implementing WH_KEYBOARD_LL hook.

Critical implementation details from research:
1. Use WH_KEYBOARD_LL (13) for global hook
2. Handle both WM_KEYDOWN (0x0100) and WM_KEYUP (0x0101)
3. Handle both WM_SYSKEYDOWN (0x0104) and WM_SYSKEYUP (0x0105) for keys like Alt+F8
4. Track `_isKeyDown` state to prevent auto-repeat flood
5. Keep callback minimal - Windows removes hooks that take >1000ms
6. Store delegate in field to prevent GC collection

```csharp
// Services/KeyboardHookService.cs
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Coxixo.Services;

public sealed class KeyboardHookService : IDisposable
{
    private const int WH_KEYBOARD_LL = 13;
    private const int WM_KEYDOWN = 0x0100;
    private const int WM_KEYUP = 0x0101;
    private const int WM_SYSKEYDOWN = 0x0104;
    private const int WM_SYSKEYUP = 0x0105;

    public event EventHandler? HotkeyPressed;
    public event EventHandler? HotkeyReleased;

    private delegate IntPtr LowLevelKeyboardProc(int nCode, IntPtr wParam, IntPtr lParam);

    // IMPORTANT: Store delegate in field to prevent garbage collection
    private readonly LowLevelKeyboardProc _proc;
    private IntPtr _hookId = IntPtr.Zero;
    private Keys _targetKey = Keys.F8;  // Default hotkey, will be configurable
    private bool _isKeyDown = false;
    private bool _disposed = false;

    public KeyboardHookService()
    {
        _proc = HookCallback;
    }

    public Keys TargetKey
    {
        get => _targetKey;
        set => _targetKey = value;
    }

    public void Start()
    {
        if (_hookId != IntPtr.Zero)
            return; // Already started

        _hookId = SetHook(_proc);
        if (_hookId == IntPtr.Zero)
        {
            var error = Marshal.GetLastWin32Error();
            throw new InvalidOperationException(
                $"Failed to install keyboard hook. Error code: {error}");
        }
    }

    public void Stop()
    {
        if (_hookId != IntPtr.Zero)
        {
            UnhookWindowsHookEx(_hookId);
            _hookId = IntPtr.Zero;
            _isKeyDown = false;
        }
    }

    private IntPtr SetHook(LowLevelKeyboardProc proc)
    {
        using var curProcess = Process.GetCurrentProcess();
        using var curModule = curProcess.MainModule!;
        return SetWindowsHookEx(WH_KEYBOARD_LL, proc,
            GetModuleHandle(curModule.ModuleName), 0);
    }

    private IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
    {
        if (nCode >= 0)
        {
            int vkCode = Marshal.ReadInt32(lParam);
            var key = (Keys)vkCode;

            if (key == _targetKey)
            {
                var msg = wParam.ToInt32();

                // Key pressed (not already down - prevents auto-repeat flood)
                if ((msg == WM_KEYDOWN || msg == WM_SYSKEYDOWN) && !_isKeyDown)
                {
                    _isKeyDown = true;
                    HotkeyPressed?.Invoke(this, EventArgs.Empty);
                }
                // Key released
                else if ((msg == WM_KEYUP || msg == WM_SYSKEYUP) && _isKeyDown)
                {
                    _isKeyDown = false;
                    HotkeyReleased?.Invoke(this, EventArgs.Empty);
                }
            }
        }
        return CallNextHookEx(_hookId, nCode, wParam, lParam);
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;
        Stop();
    }

    // P/Invoke declarations
    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr SetWindowsHookEx(int idHook,
        LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool UnhookWindowsHookEx(IntPtr hhk);

    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode,
        IntPtr wParam, IntPtr lParam);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern IntPtr GetModuleHandle(string lpModuleName);
}
```
  </action>
  <verify>
Build project: `dotnet build Coxixo/Coxixo.csproj`
Should compile without errors. Services folder should exist with KeyboardHookService.cs.
  </verify>
  <done>
KeyboardHookService.cs exists with WH_KEYBOARD_LL implementation. Exposes HotkeyPressed and HotkeyReleased events. Handles auto-repeat prevention.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire hotkey service to tray icon state changes</name>
  <files>
    Coxixo/TrayApplicationContext.cs
    Coxixo/Resources/icon-recording.ico
  </files>
  <action>
Create a second icon file (icon-recording.ico) - use a different color (e.g., red-tinted) to distinguish from idle state. This is a placeholder; Phase 4 will apply the final brand design.

Update TrayApplicationContext to:
1. Add icon-recording.ico as embedded resource in csproj
2. Create and start KeyboardHookService
3. Subscribe to HotkeyPressed/HotkeyReleased events
4. Change tray icon when recording state changes
5. Dispose KeyboardHookService on exit

Update Coxixo.csproj to include the new icon:
```xml
<ItemGroup>
  <EmbeddedResource Include="Resources\icon-idle.ico" />
  <EmbeddedResource Include="Resources\icon-recording.ico" />
</ItemGroup>
```

Update TrayApplicationContext.cs:

```csharp
// Add field
private readonly KeyboardHookService _hotkeyService;
private readonly Icon _idleIcon;
private readonly Icon _recordingIcon;

// In constructor, after tray icon setup:
_idleIcon = LoadEmbeddedIcon("Coxixo.Resources.icon-idle.ico");
_recordingIcon = LoadEmbeddedIcon("Coxixo.Resources.icon-recording.ico");

_trayIcon = new NotifyIcon
{
    Icon = _idleIcon,
    // ... rest same as before
};

_hotkeyService = new KeyboardHookService();
_hotkeyService.HotkeyPressed += OnHotkeyPressed;
_hotkeyService.HotkeyReleased += OnHotkeyReleased;
_hotkeyService.Start();

// Add event handlers
private void OnHotkeyPressed(object? sender, EventArgs e)
{
    _trayIcon.Icon = _recordingIcon;
    _trayIcon.Text = "Coxixo - Recording...";
}

private void OnHotkeyReleased(object? sender, EventArgs e)
{
    _trayIcon.Icon = _idleIcon;
    _trayIcon.Text = "Coxixo - Push to Talk";
}

// Update Dispose to clean up
protected override void Dispose(bool disposing)
{
    if (disposing)
    {
        _hotkeyService?.Dispose();
        CleanupTrayIcon();
        _idleIcon?.Dispose();
        _recordingIcon?.Dispose();
    }
    base.Dispose(disposing);
}
```

Add using statement:
```csharp
using Coxixo.Services;
```
  </action>
  <verify>
Build and run:
```bash
dotnet run --project Coxixo/Coxixo.csproj
```

Test push-to-talk:
1. Open Notepad (to ensure another app has focus)
2. Press and HOLD F8 key
3. Verify tray icon changes appearance and tooltip shows "Recording..."
4. Release F8 key
5. Verify tray icon returns to original appearance and tooltip shows "Push to Talk"
6. Repeat several times to ensure no auto-repeat issues
7. Exit app via tray menu
  </verify>
  <done>
Pressing F8 changes tray icon to recording state. Releasing F8 returns icon to idle state. Works globally regardless of which app has focus. No auto-repeat flood when holding key.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `dotnet build Coxixo/Coxixo.csproj`
2. Hotkey works globally: Open Notepad, press F8 - tray icon should change
3. Push-to-talk pattern: Hold F8 = recording icon, release F8 = idle icon
4. No auto-repeat: Hold F8 for 5 seconds, release - should only trigger press/release once each
5. Clean disposal: Exit app, run again - hook should work normally
</verification>

<success_criteria>
- KeyboardHookService implements WH_KEYBOARD_LL with HotkeyPressed/HotkeyReleased events
- Default hotkey is F8 (configurable property exists)
- Tray icon visually changes between idle and recording states
- Hotkey detection works when any application has focus
- Auto-repeat is prevented (single event per press/release)
- Hook is properly disposed on app exit
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
