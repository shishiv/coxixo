---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Coxixo/Models/AppSettings.cs
  - Coxixo/Services/ConfigurationService.cs
  - Coxixo/Services/CredentialService.cs
  - Coxixo/TrayApplicationContext.cs
autonomous: true

must_haves:
  truths:
    - "Settings persist across app restarts"
    - "API credentials are stored encrypted (not plaintext)"
    - "App starts with previously saved hotkey setting"
    - "Missing or corrupted settings file uses defaults gracefully"
  artifacts:
    - path: "Coxixo/Models/AppSettings.cs"
      provides: "Strongly-typed settings model"
      contains: "class AppSettings"
    - path: "Coxixo/Services/ConfigurationService.cs"
      provides: "JSON settings load/save"
      contains: "JsonSerializer"
    - path: "Coxixo/Services/CredentialService.cs"
      provides: "DPAPI encrypted credential storage"
      contains: "ProtectedData"
  key_links:
    - from: "Coxixo/TrayApplicationContext.cs"
      to: "Coxixo/Services/ConfigurationService.cs"
      via: "Load settings on startup"
      pattern: "ConfigurationService\\.Load"
    - from: "Coxixo/Services/CredentialService.cs"
      to: "System.Security.Cryptography"
      via: "DPAPI ProtectedData.Protect/Unprotect"
      pattern: "ProtectedData\\.(Protect|Unprotect)"
---

<objective>
Implement configuration persistence for user settings and secure credential storage.

Purpose: Users need their settings (hotkey choice, API endpoint) to persist across app restarts. API credentials must be stored securely using Windows DPAPI, not in plaintext.

Output: ConfigurationService for JSON settings, CredentialService for encrypted API key storage, AppSettings model, integrated with TrayApplicationContext.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppSettings model and ConfigurationService</name>
  <files>
    Coxixo/Models/AppSettings.cs
    Coxixo/Services/ConfigurationService.cs
  </files>
  <action>
Create Models folder and AppSettings.cs with strongly-typed settings:

```csharp
// Models/AppSettings.cs
using System.Windows.Forms;

namespace Coxixo.Models;

public class AppSettings
{
    /// <summary>
    /// The key used for push-to-talk. Default is F8.
    /// </summary>
    public Keys HotkeyKey { get; set; } = Keys.F8;

    /// <summary>
    /// Azure OpenAI endpoint URL (e.g., https://xxx.openai.azure.com/)
    /// </summary>
    public string AzureEndpoint { get; set; } = "";

    /// <summary>
    /// Azure OpenAI Whisper deployment name.
    /// </summary>
    public string WhisperDeployment { get; set; } = "whisper";

    /// <summary>
    /// API version for Azure OpenAI (default matches current stable).
    /// </summary>
    public string ApiVersion { get; set; } = "2024-02-01";
}
```

Create ConfigurationService.cs using System.Text.Json:

```csharp
// Services/ConfigurationService.cs
using System.Text.Json;
using Coxixo.Models;

namespace Coxixo.Services;

public static class ConfigurationService
{
    private static readonly string AppDataFolder = Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
        "Coxixo"
    );

    private static readonly string SettingsPath = Path.Combine(AppDataFolder, "settings.json");

    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    public static AppSettings Load()
    {
        if (!File.Exists(SettingsPath))
            return new AppSettings();

        try
        {
            var json = File.ReadAllText(SettingsPath);
            return JsonSerializer.Deserialize<AppSettings>(json, JsonOptions)
                   ?? new AppSettings();
        }
        catch (Exception)
        {
            // Corrupted file - return defaults
            return new AppSettings();
        }
    }

    public static void Save(AppSettings settings)
    {
        Directory.CreateDirectory(AppDataFolder);
        var json = JsonSerializer.Serialize(settings, JsonOptions);
        File.WriteAllText(SettingsPath, json);
    }

    /// <summary>
    /// Gets the path where settings are stored (for diagnostics).
    /// </summary>
    public static string GetSettingsPath() => SettingsPath;
}
```

IMPORTANT: Use `Environment.SpecialFolder.LocalApplicationData` (not Roaming) - this is for local machine settings that don't need to sync.
  </action>
  <verify>
Build: `dotnet build Coxixo/Coxixo.csproj`
Files exist:
- Coxixo/Models/AppSettings.cs
- Coxixo/Services/ConfigurationService.cs
  </verify>
  <done>
AppSettings model exists with HotkeyKey, AzureEndpoint, WhisperDeployment, ApiVersion properties. ConfigurationService can Load and Save settings to JSON in LocalApplicationData.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CredentialService with DPAPI encryption</name>
  <files>
    Coxixo/Services/CredentialService.cs
  </files>
  <action>
Create CredentialService.cs using Windows DPAPI:

```csharp
// Services/CredentialService.cs
using System.Security.Cryptography;
using System.Text;

namespace Coxixo.Services;

/// <summary>
/// Stores and retrieves API credentials using Windows DPAPI encryption.
/// Credentials are encrypted per-user and only readable by the same Windows account.
/// </summary>
public static class CredentialService
{
    private static readonly string AppDataFolder = Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
        "Coxixo"
    );

    private static readonly string CredentialsPath = Path.Combine(AppDataFolder, "credentials.dat");

    // Entropy adds additional protection - must be same for encrypt/decrypt
    private static readonly byte[] Entropy = Encoding.UTF8.GetBytes("Coxixo.v1.2026.Entropy");

    /// <summary>
    /// Saves the API key encrypted with DPAPI.
    /// </summary>
    public static void SaveApiKey(string apiKey)
    {
        if (string.IsNullOrEmpty(apiKey))
        {
            // Empty key - delete credentials file if exists
            if (File.Exists(CredentialsPath))
                File.Delete(CredentialsPath);
            return;
        }

        Directory.CreateDirectory(AppDataFolder);

        byte[] plaintext = Encoding.UTF8.GetBytes(apiKey);
        byte[] encrypted = ProtectedData.Protect(
            plaintext,
            Entropy,
            DataProtectionScope.CurrentUser
        );

        File.WriteAllBytes(CredentialsPath, encrypted);
    }

    /// <summary>
    /// Loads the API key, decrypting with DPAPI.
    /// Returns null if no credentials saved or decryption fails.
    /// </summary>
    public static string? LoadApiKey()
    {
        if (!File.Exists(CredentialsPath))
            return null;

        try
        {
            byte[] encrypted = File.ReadAllBytes(CredentialsPath);
            byte[] decrypted = ProtectedData.Unprotect(
                encrypted,
                Entropy,
                DataProtectionScope.CurrentUser
            );
            return Encoding.UTF8.GetString(decrypted);
        }
        catch (CryptographicException)
        {
            // Credentials corrupted or from different user account
            return null;
        }
    }

    /// <summary>
    /// Checks if credentials are stored.
    /// </summary>
    public static bool HasStoredCredentials() => File.Exists(CredentialsPath);

    /// <summary>
    /// Clears stored credentials.
    /// </summary>
    public static void ClearCredentials()
    {
        if (File.Exists(CredentialsPath))
            File.Delete(CredentialsPath);
    }
}
```

IMPORTANT: The CredentialService uses `DataProtectionScope.CurrentUser` which means:
- Credentials can only be decrypted by the same Windows user account
- If user account is deleted or machine is reimaged, credentials are lost
- This is the correct behavior for local app credentials
  </action>
  <verify>
Build: `dotnet build Coxixo/Coxixo.csproj`
File exists: Coxixo/Services/CredentialService.cs
  </verify>
  <done>
CredentialService exists with SaveApiKey, LoadApiKey, HasStoredCredentials, ClearCredentials methods. Uses DPAPI with entropy for encryption.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate configuration loading into TrayApplicationContext</name>
  <files>
    Coxixo/TrayApplicationContext.cs
  </files>
  <action>
Update TrayApplicationContext to load settings on startup and apply the configured hotkey.

Add to TrayApplicationContext.cs:

1. Add field for AppSettings:
```csharp
private readonly AppSettings _settings;
```

2. Add using statements:
```csharp
using Coxixo.Models;
```

3. In constructor, load settings BEFORE creating KeyboardHookService:
```csharp
// Load settings first
_settings = ConfigurationService.Load();

// Then create hotkey service with configured key
_hotkeyService = new KeyboardHookService();
_hotkeyService.TargetKey = _settings.HotkeyKey;
_hotkeyService.HotkeyPressed += OnHotkeyPressed;
_hotkeyService.HotkeyReleased += OnHotkeyReleased;
_hotkeyService.Start();
```

4. Update tooltip to show current hotkey:
```csharp
_trayIcon = new NotifyIcon
{
    Icon = _idleIcon,
    Text = $"Coxixo - Press {_settings.HotkeyKey} to talk",
    Visible = true,
    ContextMenuStrip = CreateContextMenu()
};
```

5. Update OnHotkeyReleased to show the configured key:
```csharp
private void OnHotkeyReleased(object? sender, EventArgs e)
{
    _trayIcon.Icon = _idleIcon;
    _trayIcon.Text = $"Coxixo - Press {_settings.HotkeyKey} to talk";
}
```

The settings are loaded but not saved in this plan - saving will be handled in Phase 4 when we build the Settings UI. For now, users can manually edit the JSON file in %LOCALAPPDATA%\Coxixo\settings.json to change the hotkey.
  </action>
  <verify>
Build and run:
```bash
dotnet run --project Coxixo/Coxixo.csproj
```

Test settings persistence:
1. Run app, note default F8 hotkey works
2. Exit app
3. Create settings file manually:
```powershell
mkdir "$env:LOCALAPPDATA\Coxixo" -Force
'{"hotkeyKey": 119}' | Out-File "$env:LOCALAPPDATA\Coxixo\settings.json" -Encoding utf8
```
(119 = F8, 120 = F9, 121 = F10 - see Keys enum)

4. Run app again
5. Verify tooltip shows configured key
6. Test that configured hotkey works

Test credential service (manual):
```powershell
# This would be called from C# code, but you can verify the file is created:
ls "$env:LOCALAPPDATA\Coxixo\credentials.dat"
```
  </verify>
  <done>
App loads settings from JSON on startup. Hotkey is configurable via settings file. Credential service is ready for use (will be integrated in Phase 3 for API key storage).
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build succeeds: `dotnet build Coxixo/Coxixo.csproj`
2. Settings file location: Check %LOCALAPPDATA%\Coxixo\ exists after first run
3. Default settings work: App runs with F8 as default hotkey
4. Settings persist: Modify settings.json, restart app, new setting is applied
5. Corrupted settings handled: Delete or corrupt settings.json, app still starts with defaults
6. CredentialService compiles: No runtime errors (full testing in Phase 3)
</verification>

<success_criteria>
- AppSettings model exists with HotkeyKey, AzureEndpoint, WhisperDeployment properties
- ConfigurationService loads/saves JSON to %LOCALAPPDATA%\Coxixo\settings.json
- CredentialService uses DPAPI to encrypt/decrypt API key
- TrayApplicationContext loads settings on startup
- Configured hotkey is applied to KeyboardHookService
- Missing/corrupted settings gracefully fall back to defaults
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
